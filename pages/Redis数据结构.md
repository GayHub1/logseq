- Redis底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。利用各个数据结构不同的特性，在不同的场景下，动态组成了了各种数据类型，对应关系如下图所示：
  ![Replaced by Image Uploder](https://cdn.jsdelivr.net/gh/GayHub1/images@master/img/image-20210113220722832_1655734960071_0.png){:height 237, :width 778} 
  Redis作为一个典型的键值对数据库，我们先来看看它的键值对都是如何保存的。
  首先Redis服务器中每个服务器都是存在RedisService中长度为dbnum（默认为16）的RedisDB数组中，所以redis默认拥有16个数据库的。
  RedisDB数组中每个数据库使用Redisdb结构来表示，而RedisDB数据库结构下的dict字典就保存该数据库所有的键值对信息；
    
  ![Replaced by Image Uploder](https://cdn.jsdelivr.net/gh/GayHub1/images@master/img/image-20210113223224391_1655735067010_0.png)
- ### Dict 字典/哈希表
    
  dict字典的底层是使用哈希表实现的，通过这哈希表可以高效的完成键值的关联与对键值对的管理。
    
  而哈希表就是多个哈希桶构成的数组。每个键值对根据键的哈希值存储在相应的哈希桶中，存储在相同哈希桶的键值对的哈希节点通过链地址法连接。因而每个键值对节点都有指向对应key，val，以及下一个节点的指针。
  ![Replaced by Image Uploder](https://cdn.jsdelivr.net/gh/GayHub1/images@master/img/image-20210118105401587_1655735145785_0.png) 
  
    
  那么作为一个哈希表，重点往往在散列函数，哈希冲突，扩容机制这几个点。
    
  **散列函数**的作用在于计算哈希key最终存储在哪个哈希槽上，因此散列函数的算法除了效率还需要尽可能的将每个节点均匀地分散到哈希槽上，让散列尽可能的均匀。
    
  redis在字典中具体使用散列的算法是 Murmurhash2。Murmurhash2是一种非加密hash算法，相对其他哈希散列算法。
    
  > *这种算法即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，计算速度非常快，使用简单。*
  
    
  **哈希冲突** 当多个哈希节点被分配到同一个哈希槽时就会产生哈希冲突，在redis中就使用链地址法来解决，每个节点都有一个next指针来连接下一个节点，用链地址的形式连接多个节点在同一个哈希槽上现成一个单向链表，每加入一个新的节点时，由于每个哈希槽指针只指向链表的表头，所以是使用头插法，插入到链表的表头位置。
    
  **渐近式rehash**
    
  由于当哈希表内所保存的哈希节点越来越多时，就需要对哈希表的大小进行扩容，通过增加哈希桶的方式，使整个哈希表的负载因子（used/size）即每一个哈希桶内链表的个数在一个合理的范围。扩容的具体方式就用上了dict结构下的rehashidx变量与ht数组中另一个哈希表了。那么具体是如何进行渐进式rehash的呢？
    
  	1. 为另一个空闲的新哈希表分配空间。空间大小为>= 两倍旧哈希表所承载节点的2^n次方。（收缩时为一倍）
  	2. 将rehashidx由默认值-1设为0；开始渐进式rehash。
  	3. 每当对字典进行操作时，除了执行原本的操作还会将旧哈希表rehashidx索引对应的哈希槽内所有的哈希节点进行rehash（重新计算哈希值并根据新哈希表大小计算出在新哈希表的哈希槽）到新的哈希表。然后rehashidx++；
  	4. 当对旧哈希表所有的键值对都rehash到新的哈希表时重新将rehashidx设为-1.
  	5. 释放的哈希表。将指向旧哈希表的指针指向新的哈希表，为原本新哈希表指针指向一个新的哈希表。这样整个渐进式rehash过程就完成了。
  
   这种渐进式rehash的方式保证了每一次的哈希表rehash的量不会过多，时间不会过久阻塞了单线程的redis。
  
   rehash的扩容触发条件会根据redis是否有在创建子进程（BGSAVE与BGREWRITEAOF）而改变。当有进行创建子进程的操作时，只有负载因子大于5才会进行rehash扩容否则只需大于1就可以进行rehash了。当负载因子小于0.1就会进行缩小。
  
   在渐进式rehash期间对字典的所有操作都会针对新旧哈希表进行操作的。
- ### 整数集合
- ### 双向链表
- ### 压缩列表
- ### skiplist 跳跃表
    
  ​	Redis使用跳跃表(skiplist)作为有序集合键的底层实现之一。skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching）。一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。因为他是基于链表实现的。算是分治查找使用链表，在牺牲空间复杂度情况下产生的结构。
    
  ​	传统意义的单链表是一个线性结构。像有序的链表中大部分操作例如：插入，查找 都是需要一个O(n)的时间；
    
  ![img](http://images.zhuoke.xyz/img/20150530162529554)
    
  ​	先来看看skiplist比较基础的结构图，使用上图中所看到的的跳跃表。由于我们能够先通过每一个节点的最上层的指针先进行查找，将查找的值与目前节点的后继节点的值进行对比，如果大于则继续与后继指针对比，否则就下沉一层然后继续循环，直到找到该值在跳跃表的位置。（最后一定下沉到最下层）这样子就能跳过大部分的节点。然后再缩减范围，对以下一层的指针进行查找，若仍未找到，缩小范围继续查找。通过在每个节点增加多个后继指针就能够大大降低降低查找所需时间。原本O（n）也降低到O(logn);
    
  基于redis是一种内存数据库，所以像使用B+tree实现索引这一类的数据结构只使用于存储在磁盘的mysql之类的数据库。基于哈希表又不满足数据库多样的需求，Redis 中的有序集合支持的核心操作主要有下面这几个：
- 插入一个数据
- 删除一个数据
- 查找一个数据
- 按照区间查找数据（比如查找在[100,356]之间的数据）
- 迭代输出有序序列 
    
  其中，插入、查找、删除以及迭代输出有序序列这几个操作，红黑树也能完成，时间复杂度和跳表是一样的，但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。
- ### SDS 简单动态字符串
    
  关于String类型底层的数据结构，虽然redis是使用c编写的，但是String并没有用c语言的字符串来实现。而是使用了一种简单动态字符串（simple dynamic string），即SDS作为Redis默认字符串的数据结构。**SDS**
    
  用于在以下方面
- 数据库的字符串
- 缓冲区（AOF模块的AOF缓冲区；客户端状态的输入缓冲区）
    
  可以看到SDS被大量应用在数据快速修改的场景。而C字符串长度每一次增加或减少都会程序都需要进行一次内存重分配。而SDS结构则进行了优化。类似于ArrayList，通过一些冗余空间来减少内存重新分配的次数，我们先来看一下SDS的结构。
    
  ```
  struct sdshdr {
  
  //字符串长度
  
     int len;
  
  //空闲字节
  
     int free;
  
  //实际存储数据buf的char型数组
  
      char buf[];
  };      
  ```
    
  SDS整个结构还是相对比较简单明了，直接存储了字符串的长度以及另外存储数组空闲字节
    
  ，这样设计就可以**直接获得字符串长度**，而不用遍历到空字符；另外使得存储数据的buf数组不用跟c字符串一样，强制使数据量与存储数据的数组容量一致，实现**空间预分配**与**惰性空间**释放大大减少了数据变化后内存空间重分配的次数。虽然SDS与C字符串一样以空字符结尾，但是SDS的APi都是二进制安全的，不但可以**避免缓冲区溢出**而且**可以使用原本C<string.h>中部分函数**。还可以保存二进制数据(图片，音视频等文件)。
- ### Redis Model