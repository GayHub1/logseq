- #[[excerpt]] [如何阅读一份代码？](https://zhuanlan.zhihu.com/p/26222486)
- tags: #[[SimpRead]]
- read date: [[2022_07_15  ]]
- desc: 上文谈到了像读书一样阅读源码的重要性，今天谈谈如何阅读一份代码。我所谓的一份代码，其范围可能从几千行到数万行，有时甚至可多达数十万行。这些代码作为一个有机体，共同完成某些重要的功能。比如说几个著名的…
- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871321361>)  从若干阅读代码的场景开始，讨论个人的读代码的一点微不足道的心得。
- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871329923>)  为了破案而阅读代码
  collapsed:: true
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871351787>)  带着线索，从一堆代码中找出和问题相关的代码。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871357843>)  专注阅读挑出来的内容，忽略不相干的噪音。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871370689>)  编译运行修改过的代码，复现问题，分析调试信息
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871384229>)  复盘
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871399277>)  这个问题的 root cause 是什么？触发它的代码的流程是什么？
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871401724>)  在读代码的过程中，哪些地方我猜对了，哪些没猜对？
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871404292>)  有功夫的话，代码的哪个部分是值得细细品读把玩的？
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871407713>)  下次再出现类似的问题，我该怎么更快地从源码中定位出问题？
- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871423210>)  为了明理而阅读代码
  collapsed:: true
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871573971>)  计算机领域的很多算法，基础知识，理论，在看过书，读过文章后我们都似懂非懂，这时，阅读代码就是最快地巩固和加深理解的方式：
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871588040>)  算法
	  collapsed:: true
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871591186>)  bloom filter 究竟怎么实现的？怎么样把 bandit 算法在自己的系统上做简单的推荐？ossip 协议实际的生产环境的代码是什么样子的？Linux kernel 如何实现 O(1) scheduler？
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871593932>)  基础知识
	  collapsed:: true
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871597780>)  一个完整的涵盖 HTTP 1.1 协议的 REST API framework 如何实现？一个 packet 从 OS 的 driver 是如何一路送上 application 的？什么是 zero copy？Linux kernel 如何实现 zero copy？
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871611043>)  理论
	  collapsed:: true
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871614018>)  啥是 IoC / DI / Pub Sub？各种 framework 都是咋实现这些设计模式的？supervisor 这个 behavior 背后的实现是如何的？
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871874360>)  心满意足后，我一般会问问：
	  collapsed:: true
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871879994>)  这代码有可以优化的地方么？
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871883409>)  有潜在的安全漏洞么？
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871886730>)  是否有未处理的状态或者异常？
	- 过程
		- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871956297>)  先使用前面所述的检视阅读法把整个代码过一遍，找到值得阅读的核心代码。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871968841>)  粗读这部分代码，将其内容进一步 breakdown。手边准备好笔和纸（或者其他趁手的工具），随时记录。记录最好的方式是图表。这个阶段的记录不建议用软件工具（除非有用着特别舒服的，能够人件合一的）。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871976151>)  精读这部分代码，结合你已有的知识，理解这个代码所需要的资料，猜测和还原代码中某种事件，消息，或者某个流程发生的场景。把猜测记录下来。这时，如果遇到外围的代码（调用了外部的函数），只要对理解不产生障碍，可以先放一下，把整个过程完整而详细地捋一遍再说。这个过程一定要多问问题，把「我以为我懂了但实际没懂」的情形尽可能减少。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871982143>)  用检视阅读法粗度剩下的代码，如果找到其他值得精读的代码，跳至 2。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871986506>)  使用对比阅读（或者说，主题阅读）方式，把类似功能的 repo 都扫一遍。尝试着用自己的语言消化不同作者的实现，关注其实现的差异，并试图评判这种差异。
	- [📌](<http://localhost:7026/reading/29?title=如何阅读一份代码？#id=1657871989853>)  用软件将手稿电子化，便于将来回顾。文字可以直接上笔记本工具（甚至可以尝试 gitbook），图表如果买不起 visio，omniGraffle 这样的工具，可以用 plantuml。使用方法参考我的文章：[那些年，我追过的绘图工具](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzA3NDM0ODQwMw%3D%3D%26mid%3D203733442%26idx%3D1%26sn%3D720a2ca2c59ea862155b93600b53946c%26scene%3D21%23wechat_redirect)